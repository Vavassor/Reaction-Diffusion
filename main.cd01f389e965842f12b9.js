(self.webpackChunkreaction_diffusion=self.webpackChunkreaction_diffusion||[]).push([[792],{694:(e,t,r)=>{"use strict";class n{constructor(e,t,r){this.r=e,this.g=t,this.b=r}toArray(){return[this.r,this.g,this.b]}toHex(){const e=Math.floor(255*this.r),t=Math.floor(255*this.g),r=Math.floor(255*this.b);return e.toString(16).padStart(2,"0")+t.toString(16).padStart(2,"0")+r.toString(16).padStart(2,"0")}toRgba(){return[this.r,this.g,this.b,1]}static black(){return new n(0,0,0)}static fromHex(e){const t=parseInt(e.substring(0,2),16)/255,r=parseInt(e.substring(2,4),16)/255,s=parseInt(e.substring(4,6),16)/255;return new n(t,r,s)}static fromHsv(e,t,r){const s=e/60,i=t,a=r,o=Math.floor(s),l=s-o,c=a*(1-i),d=a*(1-l*i),u=a*(1-(1-l)*i),h=o%6;return new n([a,d,c,c,u,a][h],[u,a,a,d,c,c][h],[c,c,u,a,a,d][h])}static toHsv(e){const t=e.r,r=e.g,n=e.b,s=Math.max(t,r,n),i=Math.min(t,r,n),a=s,o=s-i,l=0===s?0:o/s;let c=s;if(s===i)c=0;else{switch(s){case t:c=(r-n)/o+(r<n?6:0);break;case r:c=(n-t)/o+2;break;case n:c=(t-r)/o+4}c*=60}return{hue:c,saturation:l,value:a}}static white(){return new n(1,1,1)}}function s(e,t,r){return Math.min(Math.max(e,t),r)}function i(e,t,r){return(1-r)*e+r*t}function a(e,t,r,n,s){return i(e,t,o(r,n,s))}function o(e,t,r){return(r-e)/(t-e)}class l{constructor(e){let t,r,n;if(e.anchor){r=document.createElement("div"),r.classList.add("slider-2d"),r.setAttribute("tabindex","0");const s=document.createElement("div");s.classList.add("slider-2d-box"),r.appendChild(s),t=document.createElement("div"),t.classList.add("slider-2d-bounds"),s.appendChild(t),n=document.createElement("div"),n.classList.add("slider-2d-selector"),t.appendChild(n),e.anchor.appendChild(r)}else t=document.getElementById(e.boundsId),r=document.getElementById(e.id),n=document.getElementById(e.selectorId);e.label&&r.setAttribute("aria-label",e.label),this.bounds=t,this.disabled=!1,this.onInputChange=e.onInputChange,this.slider2d=r,this.selector=n,r.addEventListener("pointerdown",(e=>{this.disabled||(this.onPointerMove(e),r.setPointerCapture(e.pointerId))})),r.addEventListener("pointerup",(e=>{this.disabled||r.releasePointerCapture(e.pointerId)})),r.addEventListener("pointermove",(e=>{this.disabled||this.onPointerMove(e)})),r.addEventListener("keydown",(e=>{if(!this.disabled){let t=0,r=0;switch(e.key){case"ArrowDown":r++;break;case"ArrowLeft":t--;break;case"ArrowRight":t++;break;case"ArrowUp":r--}if(t||r){e.preventDefault();const n=.05;t*=n,r*=n,this.translateSelector(t,r)}}}))}focus(){this.slider2d.focus()}onPointerMove(e){if(!e.pressure)return;const t=this.bounds,r=this.selector,n=this.slider2d.getBoundingClientRect(),i=t.getBoundingClientRect(),a=r.getBoundingClientRect(),o=i.left-n.left,l=i.top-n.top;let c=e.clientX-n.left-o,d=e.clientY-n.top-l;c=s(c,0,i.width),d=s(d,0,i.height),r.style.left=c-a.width/2+"px",r.style.top=d-a.height/2+"px",this.onInputChange(c/i.width,1-d/i.height)}setBackgroundColor(e){this.bounds.style.backgroundColor=`#${e.toHex()}`}setBoundsClass(e){this.bounds.classList.add(e)}setDisabled(e){this.disabled=e,this.slider2d.setAttribute("aria-disabled",e)}setSelectorColor(e){this.selector.style.backgroundColor=`#${e.toHex()}`}setSelectorPosition(e,t){const r=this.bounds,n=this.selector,s=r.getBoundingClientRect(),i=n.getBoundingClientRect();let a=s.width*e,o=s.height*(1-t);n.style.left=a-i.width/2+"px",n.style.top=o-i.height/2+"px"}translateSelector(e,t){const r=this.bounds,n=this.selector,i=this.slider2d.getBoundingClientRect(),a=r.getBoundingClientRect(),o=n.getBoundingClientRect(),l=a.left-i.left,c=a.top-i.top,d=e*a.width,u=t*a.height;let h=o.left+o.width/2-i.left-l+d,m=o.top+o.height/2-i.top-c+u;h=s(h,0,a.width),m=s(m,0,a.height),n.style.left=h-o.width/2+"px",n.style.top=m-o.height/2+"px",this.onInputChange(h/a.width,1-m/a.height)}}class c{constructor(e){let t,r;if(e.anchor){const n=document.createElement("div");r=new l({anchor:n,label:"Saturation and Value",onInputChange:(e,t)=>this.onSvChange(e,t)}),r.setBoundsClass("sv-picker-bounds"),t=document.createElement("input"),t.classList.add("hue-slider","form-control"),t.setAttribute("type","range"),t.setAttribute("value",0),t.setAttribute("min",0),t.setAttribute("max",360),t.setAttribute("step","any"),t.setAttribute("aria-label","Hue"),n.appendChild(t),e.anchor.appendChild(n)}else{const n={id:e.svPicker.id,boundsId:e.svPicker.boundsId,selectorId:e.svPicker.selectorId,onInputChange:(e,t)=>this.onSvChange(e,t)};r=new l(n),t=document.getElementById(e.hueSliderId)}this.hue=0,this.hueSlider=t,this.onInputChange=e.onInputChange,this.saturation=0,this.svPicker=r,this.value=0,this.hueSlider.addEventListener("input",(e=>{this.onHueChange(e.currentTarget.value)}))}focus(){this.svPicker.focus()}onHueChange(e){const t=e;this.hue=t;const r=n.fromHsv(t,1,1);this.svPicker.setBackgroundColor(r);const s=n.fromHsv(t,this.saturation,this.value);this.svPicker.setSelectorColor(s),this.onInputChange(s)}onSvChange(e,t){const r=e,s=t;this.saturation=r,this.value=s;const i=n.fromHsv(this.hue,r,s);this.svPicker.setSelectorColor(i),this.onInputChange(i)}setColor(e){const t=n.toHsv(e),r=t.hue,s=t.saturation,i=t.value,a=n.fromHsv(r,1,1);this.hue=r,this.saturation=s,this.value=i,this.hueSlider.setAttribute("value",r),this.svPicker.setSelectorColor(e),this.svPicker.setBackgroundColor(a),this.svPicker.setSelectorPosition(s,i)}}class d{constructor(e){this.onColorChange=e.onColorChange,this.color=e.initialColor,this.onClick=this.onClick.bind(this),document.getElementById(e.buttonId).addEventListener("click",this.onClick)}onClick(e){const t=e.currentTarget;this.openPopover(t)}openPopover(e){const t=document.createElement("div");t.classList.add("popover"),t.addEventListener("focusout",(r=>{t.contains(r.relatedTarget)||e.parentElement.removeChild(t)}));const r=new c({anchor:t,onInputChange:t=>{this.color=t,this.onColorChange(t),e.style.backgroundColor=`#${t.toHex()}`}});e.insertAdjacentElement("afterend",t),r.setColor(this.color),r.focus()}}var u=r(213),h=r.n(u);var m=r(498),p=r.n(m),f=r(721),_=r.n(f),v=r(404),x=r.n(v),y=r(762),g=r.n(y),b=r(849),w=r.n(b),E=r(42),R=r.n(E),A=r(349),F=r.n(A),T=r(825),k=r.n(T),S=r(679),I=r.n(S),M=r(661),C=r.n(M);function U(e,t,r){const n=s(o(e,t,r),0,1);return n*n*(3-2*n)}function z(e){const t=new Array(e.x*e.y);for(let r=0;r<e.y;r++)for(let n=0;n<e.x;n++)t[e.x*r+n]=Math.random()<.3;const r=new Float32Array(4*e.x*e.y);for(let n=0;n<e.y;n++)for(let s=0;s<e.x;s++){const i=4*(e.x*n+s);t[Math.floor(n/10)*e.x+Math.floor(s/10)]?(r[i]=.5+.02*Math.random()-.01,r[i+1]=.25+.02*Math.random()-.01):(r[i]=1,r[i+1]=0)}return r}function L(e){const t=new Uint8Array(4*e*e),r=e/2;for(let n=0;n<e;n++)for(let s=0;s<e;s++){const i=4*(e*n+s),a=s+.5-r,o=n+.5-r,l=255*(1-U(r-2,r,Math.sqrt(a*a+o*o)));t[i]=l,t[i+1]=l,t[i+2]=l,t[i+3]=l}return t}function P(e){const t=new Uint8Array(3*e.x*e.y),r=[n.fromHex("3f167d"),n.fromHex("b3074f"),n.fromHex("e65005"),n.fromHex("ffade5")];for(let n=0;n<e.y;n++)for(let s=0;s<e.x;s++){const i=3*(e.x*n+s),a=Math.floor(s/10),o=r[(1&Math.floor(n/10))<<1|1&a];t[i]=Math.floor(255*o.r),t[i+1]=Math.floor(255*o.g),t[i+2]=Math.floor(255*o.b)}return t}function B(e){const t=new Uint8Array(3*e.x*e.y),r=2/Math.min(e.x,e.y);for(let n=0;n<e.y;n++)for(let s=0;s<e.x;s++){const i=3*(e.x*n+s),a=Math.sin(2*Math.PI*r*n),o=Math.sin(2*Math.PI*r*s);t[i]=Math.floor(255*(.5*a+.5)),t[i+1]=Math.floor(255*(.5*o+.5))}return t}function D(e){const t=new Float32Array(4*e.x*e.y),r=2/Math.min(e.x,e.y);for(let n=0;n<e.y;n++)for(let s=0;s<e.x;s++){const i=4*(e.x*n+s),a=Math.sin(2*Math.PI*r*n),o=Math.sin(2*Math.PI*r*s);t[i]=a,t[i+1]=o}return t}function N(e){const t=new Uint8Array(3*e.x*e.y),r=Math.min(e.x,e.y)/5;for(let n=0;n<e.y;n++)for(let s=0;s<e.x;s++){const i=3*(e.x*n+s),o=s/r,l=n/r,c=.25*(Math.sin(Math.PI*o)+Math.sin(Math.PI*l))+.5,d=.25*(Math.sin(6.7*Math.PI*o)+Math.sin(6.7*Math.PI*l))+.5;t[i]=Math.floor(a(120,160,0,1,c)),t[i+1]=Math.floor(255*d)}return t}class G{constructor(e,t,r){this.elements=[e,t,r]}get length(){return Math.sqrt(this.squaredLength)}get squaredLength(){const[e,t,r]=this.elements;return e*e+t*t+r*r}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}toString(){return`⟨${this.x}, ${this.y}, ${this.z}⟩`}static add(e,t){return new G(e.x+t.x,e.y+t.y,e.z+t.z)}static cross(e,t){return new G(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x)}static distance(e,t){return G.subtract(t,e).length}static dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static lerp(e,t,r){return new G(i(e.x,t.x,r),i(e.y,t.y,r),i(e.z,t.z,r))}static multiply(e,t){return new G(e*t.x,e*t.y,e*t.z)}static normalize(e){const t=e.length;return new G(e.x/t,e.y/t,e.z/t)}static subtract(e,t){return new G(e.x-t.x,e.y-t.y,e.z-t.z)}static zero(){return new G(0,0,0)}}class O{constructor(e){this.e=e}get float32Array(){return new Float32Array(this.e)}get transpose(){const{e}=this;return new O([e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]])}static dilate(e){return new O([e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1])}static identity(){return new O([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}static lookAtRh(e,t,r){const n=G.normalize(G.subtract(e,t)),s=G.normalize(G.cross(r,n)),i=G.normalize(G.cross(n,s));return O.view(s,i,n,e)}static multiply(e,t){const r=[];for(let n=0;n<4;n++)for(let s=0;s<4;s++){let i=0;for(let r=0;r<4;r++)i+=e.e[4*n+r]*t.e[4*r+s];r[4*n+s]=i}return new O(r)}static orthographicProjectionRh(e,t,r,n){const s=r-n,i=[];return i[0]=2/e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2/t,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2/s,i[11]=(n+r)/s,i[12]=0,i[13]=0,i[14]=0,i[15]=1,new O(i)}static perspectiveProjectionRh(e,t,r,n,s){const i=1/Math.tan(e/2),a=t/r,o=n-s,l=[];return l[0]=i/a,l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=i,l[6]=0,l[7]=0,l[8]=0,l[9]=0,l[10]=(n+s)/o,l[11]=2*n*s/o,l[12]=0,l[13]=0,l[14]=-1,l[15]=0,new O(l)}static translate(e){return new O([1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1])}static view(e,t,r,n){const s=[];return s[0]=e.x,s[1]=e.y,s[2]=e.z,s[3]=-G.dot(e,n),s[4]=t.x,s[5]=t.y,s[6]=t.z,s[7]=-G.dot(t,n),s[8]=r.x,s[9]=r.y,s[10]=r.z,s[11]=-G.dot(r,n),s[12]=0,s[13]=0,s[14]=0,s[15]=1,new O(s)}}var H=r(177),j=r.n(H),X=r(973),V=r.n(X);class q{constructor(e){const t=1/120,r=e.gl,n=e.glo,s=e.canvasSize,i=n.createShader(r.FRAGMENT_SHADER,k()),a=n.createShader(r.VERTEX_SHADER,p()),o=n.createShader(r.FRAGMENT_SHADER,I()),l=n.createShader(r.FRAGMENT_SHADER,C()),c=n.createShader(r.FRAGMENT_SHADER,j()),d=n.createShader(r.FRAGMENT_SHADER,V()),u=n.createShaderProgram({shaders:{vertex:a,fragment:i},uniforms:["delta_time","texture_size","input_texture","velocity_field","model_view_projection"]}),h=n.createShaderProgram({shaders:{vertex:a,fragment:o},uniforms:["velocity_field","compensation_field","model_view_projection"]}),m=n.createShaderProgram({shaders:{vertex:a,fragment:l},uniforms:["delta_time","density","velocity_field","velocity_field_size","model_view_projection"]}),f=n.createShaderProgram({shaders:{vertex:a,fragment:c},uniforms:["field_size","divergence_field","pressure_field","model_view_projection"]}),_=n.createShaderProgram({shaders:{vertex:a,fragment:d},uniforms:["delta_time","density","field_size","velocity_field","pressure_field","model_view_projection"]});u.use(),u.setUniform1f("delta_time",t),u.setUniform2fv("texture_size",s.elements),u.setUniform1i("input_texture",0),u.setUniform1i("velocity_field",1),u.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),h.use(),h.setUniform1i("velocity_field",0),h.setUniform1i("compensation_field",1),h.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),m.use(),m.setUniform1f("delta_time",t),m.setUniform1f("density",1),m.setUniform1i("velocity_field",0),m.setUniform2fv("velocity_field_size",s.elements),m.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),f.use(),f.setUniform2fv("field_size",s.elements),f.setUniform1i("divergence_field",0),f.setUniform1i("pressure_field",1),f.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),_.use(),_.setUniform1f("delta_time",t),_.setUniform1f("density",1),_.setUniform2fv("field_size",s.elements),_.setUniform1i("velocity_field",0),_.setUniform1i("pressure_field",1),_.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array);const v={advect:u,bfecc:h,divergence:m,pressure:f,subtractPressureGradient:_},x={size:s},y={size:s},g={contents:D(s),size:s},b={divergence:n.createTexture(x),pressure:[n.createTexture(y),n.createTexture(y)],velocityField:[n.createTexture(g),n.createTexture(g),n.createTexture(g)]},w={divergence:n.createFramebuffer(b.divergence),pressure:[n.createFramebuffer(b.pressure[0]),n.createFramebuffer(b.pressure[1])],velocityField:[n.createFramebuffer(b.velocityField[0]),n.createFramebuffer(b.velocityField[1]),n.createFramebuffer(b.velocityField[2])]};this.deltaTime=t,this.framebuffers=w,this.gl=e.gl,this.programs=v,this.textures=b}resize(e){const t=this.programs.advect,r=this.programs.divergence,n=(this.gl,this.programs.pressure),s=this.programs.subtractPressureGradient,i=this.textures,a=function(e){const t=new Float32Array(4*e.x*e.y);for(let r=0;r<e.y;r++)for(let n=0;n<e.x;n++){const s=4*(e.x*r+n);t[s]=0,t[s+1]=0,t[s+2]=0,t[s+3]=0}return t}(e);i.divergence.update(e,a);const o=a;i.pressure[0].update(e,o),i.pressure[1].update(e,o);const l=D(e);i.velocityField[0].update(e,l),i.velocityField[1].update(e,l),i.velocityField[2].update(e,l),t.use(),t.setUniform2fv("texture_size",e.elements),r.use(),r.setUniform2fv("velocity_field_size",e.elements),n.use(),n.setUniform2fv("field_size",e.elements),s.use(),s.setUniform2fv("field_size",e.elements)}advectVelocity(){const e=this.programs.advect,t=this.programs.bfecc,r=this.deltaTime,n=this.framebuffers,s=this.gl,i=this.textures;e.use(),s.bindFramebuffer(s.FRAMEBUFFER,n.velocityField[1]),i.velocityField[0].bind(0),i.velocityField[0].bind(1),s.drawArrays(s.TRIANGLE_STRIP,0,4),s.bindFramebuffer(s.FRAMEBUFFER,n.velocityField[2]),e.setUniform1f("delta_time",-r),i.velocityField[1].bind(0),i.velocityField[1].bind(1),s.drawArrays(s.TRIANGLE_STRIP,0,4),t.use(),s.bindFramebuffer(s.FRAMEBUFFER,n.velocityField[1]),i.velocityField[0].bind(0),i.velocityField[2].bind(1),s.drawArrays(s.TRIANGLE_STRIP,0,4),e.use(),e.setUniform1f("delta_time",r),s.bindFramebuffer(s.FRAMEBUFFER,n.velocityField[2]),i.velocityField[1].bind(0),i.velocityField[1].bind(1),s.drawArrays(s.TRIANGLE_STRIP,0,4)}computeDivergence(){const e=this.programs.divergence,t=this.framebuffers,r=this.gl,n=this.textures;e.use(),r.bindFramebuffer(r.FRAMEBUFFER,t.divergence),n.velocityField[2].bind(0),r.drawArrays(r.TRIANGLE_STRIP,0,4)}computePressure(){const e=this.framebuffers,t=this.gl,r=this.programs.pressure,n=this.textures;r.use();for(let r=0;r<10;r++)t.bindFramebuffer(t.FRAMEBUFFER,e.pressure[r%2^1]),n.divergence.bind(0),n.pressure[r%2].bind(1),t.drawArrays(t.TRIANGLE_STRIP,0,4)}subtractPressureGradient(){const e=this.framebuffers,t=this.gl,r=this.programs.subtractPressureGradient,n=this.textures;r.use(),t.bindFramebuffer(t.FRAMEBUFFER,e.velocityField[0]),n.velocityField[2].bind(0),n.pressure[0].bind(1),t.drawArrays(t.TRIANGLE_STRIP,0,4)}advectInput(e,t){const r=this.programs.advect,n=this.gl,s=this.textures;r.use(),n.bindFramebuffer(n.FRAMEBUFFER,t),e.bind(0),s.velocityField[0].bind(1),n.drawArrays(n.TRIANGLE_STRIP,0,4)}drawFlow(e,t){this.advectVelocity(),this.computeDivergence(),this.computePressure(),this.subtractPressureGradient(),this.advectInput(e,t)}drawVelocityField(e){const t=this.gl,r=this.textures;e.use(),r.velocityField[0].bind(0),t.drawArrays(t.TRIANGLE_STRIP,0,4)}bindVelocityFramebuffer(){const e=this.framebuffers,t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e.velocityField[0])}}class Y{constructor(e,t){const r=e.gl,n=t.shaders.fragment,s=t.shaders.vertex,i=e.createAndLinkProgram(s,n);e.setUpVertexLayout(i);let a={};for(const e of t.uniforms){const t=r.getUniformLocation(i,e);if(!t)throw new Error(`The location of uniform ${e} was not found`);a[e]=t}this.gl=r,this.handle=i,this.uniformLocations=a}assertUniformExists(e){if(!this.uniformLocations.hasOwnProperty(e))throw new Error(`The uniform ${e} does not exist.`)}setUniform1f(e,t){const r=this.gl,n=this.uniformLocations;this.assertUniformExists(e),r.uniform1f(n[e],t)}setUniform1i(e,t){const r=this.gl,n=this.uniformLocations;this.assertUniformExists(e),r.uniform1i(n[e],t)}setUniform2fv(e,t){const r=this.gl,n=this.uniformLocations;this.assertUniformExists(e),r.uniform2fv(n[e],t)}setUniform4fv(e,t){const r=this.gl,n=this.uniformLocations;this.assertUniformExists(e),r.uniform4fv(n[e],t)}setUniformMatrix4fv(e,t){const r=this.gl,n=this.uniformLocations;this.assertUniformExists(e),r.uniformMatrix4fv(n[e],!1,t)}use(){const e=this.gl,t=this.handle;e.useProgram(t)}}class W{constructor(e,t){t.filter=t.filter||{};const r=t.contents||null,n=t.format||e.RGBA,s=t.internalFormat||e.RGBA,i=t.filter.minify||e.NEAREST,a=t.filter.magnify||e.NEAREST,o=t.size,l=t.type||e.FLOAT,c=e.createTexture();e.bindTexture(e.TEXTURE_2D,c),e.pixelStorei(e.UNPACK_ALIGNMENT,1),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,s,o.x,o.y,0,n,l,r),t.generate_mipmaps&&e.generateMipmap(e.TEXTURE_2D),this.format=n,this.gl=e,this.handle=c,this.size=o,this.internalFormat=s,this.type=l}bind(e){const t=this.gl;t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,this.handle)}update(e,t){const r=this.gl;if(this.size=e,this.bind(0),t instanceof HTMLImageElement||t instanceof ImageBitmap){const e=r.RGBA,n=r.RGBA,s=r.UNSIGNED_BYTE;this.format=n,this.internalFormat=e,this.type=s,r.texImage2D(r.TEXTURE_2D,0,e,n,s,t)}else if(t instanceof Uint8Array||t instanceof Float32Array){const n=this.format,s=this.internalFormat,i=this.type;r.texImage2D(r.TEXTURE_2D,0,s,e.x,e.y,0,n,i,t)}else if(t)throw new Error("The content type is unsupported.")}}class ${constructor(e){this.gl=e}checkCompatibility(){const e=this.gl;if(!e)throw new Error("WebGL is not supported.");if(!e.getExtension("OES_texture_float"))throw new Error("The WebGL extension OES_texture_float is not supported.");const t=e.getParameter(e.MAX_TEXTURE_SIZE);if(t<512)throw new Error(`WebGL texture sizes of at least 512x512 are required, but only ${t}x${t} are supported.`)}createAndLinkProgram(e,t){const r=this.gl,n=r.createProgram();if(r.attachShader(n,e),r.attachShader(n,t),r.linkProgram(n),!r.getProgramParameter(n,r.LINK_STATUS)){const e=r.getProgramInfoLog(n);throw new Error("Failed to link program: "+e)}return n}createFramebuffer(e){const t=this.gl,r=t.createFramebuffer();return t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.handle,0),r}createShader(e,t){const r=this.gl,n=r.createShader(e);if(r.shaderSource(n,t),r.compileShader(n),!r.getShaderParameter(n,r.COMPILE_STATUS)){const e=r.getShaderInfoLog(n);throw new Error("Failed to compile shader: "+e)}return n}createShaderProgram(e){return new Y(this,e)}createTexture(e){return new W(this.gl,e)}loadVertexData(){const e=this.gl,t=new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,1,1,1,1]);e.bindBuffer(e.ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}setUpVertexLayout(e){const t=this.gl,r=t.getAttribLocation(e,"position"),n=t.getAttribLocation(e,"texcoord");t.enableVertexAttribArray(r),t.vertexAttribPointer(r,2,t.FLOAT,!1,16,0),-1!==n&&(t.enableVertexAttribArray(n),t.vertexAttribPointer(n,2,t.FLOAT,!1,16,8))}}var K=r(666),J=r.n(K),Z=r(114),Q=r.n(Z);class ee{constructor(e,t){this.elements=[e,t]}get length(){return Math.sqrt(this.squaredLength)}get squaredLength(){const[e,t]=this.elements;return e*e+t*t}get x(){return this.elements[0]}get y(){return this.elements[1]}toString(){return`⟨${this.x}, ${this.y}⟩`}static multiply(e,t){return new ee(e*t.x,e*t.y)}static normalize(e){const t=e.length;return new ee(e.x/t,e.y/t)}static zero(){return new ee(0,0)}}const te="ORIENTATION_MAP",re="SIMULATION_STATE",ne="STYLE_MAP",se="VELOCITY_FIELD";class ie{constructor(e,t,r){e.width=t,e.height=r;const s=new ee(t,r),i={premultipliedAlpha:!1,preserveDrawingBuffer:!0},a=e.getContext("webgl",i)||e.getContext("experimental-webgl",i);this.gl=a;const o=new $(a);this.glo=o,o.checkCompatibility(),o.loadVertexData();const l=o.createShader(a.VERTEX_SHADER,p()),c=o.createShader(a.VERTEX_SHADER,J()),d=o.createShader(a.FRAGMENT_SHADER,_()),u=o.createShader(a.FRAGMENT_SHADER,x()),h=o.createShader(a.FRAGMENT_SHADER,g()),m=o.createShader(a.FRAGMENT_SHADER,w()),f=o.createShader(a.FRAGMENT_SHADER,R()),v=o.createShader(a.FRAGMENT_SHADER,F()),y=o.createShader(a.FRAGMENT_SHADER,Q()),b=o.createShaderProgram({shaders:{vertex:l,fragment:u},uniforms:["brush_shape","brush_color","model_view_projection"]}),E=o.createShaderProgram({shaders:{vertex:l,fragment:d},uniforms:["brush_shape","brush_color","model_view_projection"]}),A=o.createShaderProgram({shaders:{vertex:c,fragment:h},uniforms:["image_dimensions","image"]}),T=o.createShaderProgram({shaders:{vertex:l,fragment:m},uniforms:["texture_size","ink","model_view_projection"]}),k=o.createShaderProgram({shaders:{vertex:c,fragment:f},uniforms:["state","ink","state_size","background_color"]}),S=o.createShaderProgram({shaders:{vertex:l,fragment:v},uniforms:["field","model_view_projection"]}),I=o.createShaderProgram({shaders:{vertex:c,fragment:y},uniforms:["state_size","state","style_map","orientation_map","canvas_feed_rate","flow_rate","canvas_kill_rate","apply_orientation_map","apply_style_map"]});b.use(),b.setUniform1i("brush_shape",0),b.setUniform4fv("brush_color",n.black().toRgba()),b.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),E.use(),E.setUniform1i("brush_shape",0),E.setUniform4fv("brush_color",n.black().toRgba()),E.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),A.use(),A.setUniform2fv("image_dimensions",s.elements),A.setUniform1i("image",0),T.use(),T.setUniform2fv("texture_size",s.elements),T.setUniform1i("ink",0),T.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),k.use(),k.setUniform1i("state",0),k.setUniform1i("ink",1),k.setUniform2fv("state_size",s.elements),S.use(),S.setUniform1i("field",0),S.setUniformMatrix4fv("model_view_projection",O.identity().transpose.float32Array),I.use(),I.setUniform2fv("state_size",s.elements),I.setUniform1i("state",0),I.setUniform1i("style_map",1),I.setUniform1i("orientation_map",2);const M={contents:L(64),filter:{magnify:a.LINEAR,minify:a.LINEAR_MIPMAP_LINEAR},format:a.RGBA,generate_mipmaps:!0,internalFormat:a.RGBA,size:new ee(64,64),type:a.UNSIGNED_BYTE},C={contents:P(s),format:a.RGB,internalFormat:a.RGB,type:a.UNSIGNED_BYTE,size:s},U={contents:B(s),format:a.RGB,internalFormat:a.RGB,size:s,type:a.UNSIGNED_BYTE},D={contents:z(s),size:s},H={contents:N(s),format:a.RGB,internalFormat:a.RGB,size:s,type:a.UNSIGNED_BYTE},j={brushShape:o.createTexture(M),ink:[o.createTexture(C),o.createTexture(C)],orientationMap:o.createTexture(U),state:[o.createTexture(D),o.createTexture(D)],styleMap:o.createTexture(H)},X={ink:[o.createFramebuffer(j.ink[0]),o.createFramebuffer(j.ink[1])],state:[o.createFramebuffer(j.state[0]),o.createFramebuffer(j.state[1])]};I.use(),a.bindFramebuffer(a.FRAMEBUFFER,X.state[0]);const V=a.checkFramebufferStatus(a.FRAMEBUFFER);if(V!==a.FRAMEBUFFER_COMPLETE)throw new Error("Cannot render to framebuffer: "+V);this.brush={color:n.fromHex("00ffcc"),endStrokeNextFrame:!1,position:new G(-16,32,0),positions:[],radius:16,state:0,strokeStepStart:0,velocity:ee.zero()},this.camera={height:r,projection:O.orthographicProjectionRh(t,r,-1,1),width:t},this.canvas=e,this.displayImage=re,this.flowSim=new q({canvasSize:s,gl:a,glo:o}),this.framebuffers=X,this.iterationsPerFrame=16,this.nextFrameChange={clear:!1},this.pageIndex=0,this.paused=!1,this.programs={brush:b,brushCutout:E,canvasTexture:A,diffuseInk:T,display:k,displayField:S,simulate:I},this.textures=j,this.update={applyFlowMap:!1,applyOrientationMap:!1,applyStyleMap:!1,backgroundColor:n.black(),feedRate:.0545,flowRate:1,killRate:.062}}clear(){this.nextFrameChange.clear=!0}drawBrush(e,t){const r=this.brush,n=this.textures;let s=0;return 2===r.state&&r.positions.length>1&&(t.use(),n.brushShape.bind(0),t.setUniform4fv("brush_color",e.toRgba()),s=this.drawBrushStroke(t)),r.endStrokeNextFrame&&r.positions.length>0&&(t.use(),n.brushShape.bind(0),t.setUniform4fv("brush_color",e.toRgba()),this.drawBrushDot(r.positions[0],t)),s}drawBrushDot(e,t){const r=this.brush,n=this.gl,s=O.dilate(new G(r.radius,r.radius,1)),i=O.translate(e),a=O.multiply(i,s),o=O.multiply(this.camera.projection,a);t.setUniformMatrix4fv("model_view_projection",o.transpose.float32Array),n.drawArrays(n.TRIANGLE_STRIP,0,4)}drawBrushStroke(e){const t=this.brush;let r=t.strokeStepStart;for(let n=0;n<t.positions.length-1;n++){const s=t.positions[n],i=t.positions[n+1],a=G.distance(s,i),o=.5*t.radius;if(r<a){let t=r;for(;t<=a;t+=o){const r=G.lerp(s,i,t/a);this.drawBrushDot(r,e)}r=t-a}else r-=a}return r}resize(e){const t=this.camera,r=this.canvas,n=this.programs.canvasTexture,s=this.programs.diffuseInk,i=this.programs.display,a=this.programs.simulate,o=this.textures;r.width=e.x,r.height=e.y,t.width=e.x,t.height=e.y,t.projection=O.orthographicProjectionRh(e.x,e.y,-1,1);const l=P(e);o.ink[0].update(e,l),o.ink[1].update(e,l);const c=B(e);o.orientationMap.update(e,c);const d=z(e);o.state[0].update(e,d),o.state[1].update(e,d);const u=N(e);o.styleMap.update(e,u),n.use(),n.setUniform2fv("image_dimensions",e.elements),s.use(),s.setUniform2fv("texture_size",e.elements),i.use(),i.setUniform2fv("state_size",e.elements),a.use(),a.setUniform2fv("state_size",e.elements),this.flowSim.resize(e)}setApplyFlowMap(e){this.update.applyFlowMap=e}setApplyOrientationMap(e){this.update.applyOrientationMap=e}setApplyStyleMap(e){this.update.applyStyleMap=e}setBackgroundColor(e){this.update.backgroundColor=e}setBrushColor(e){this.brush.color=e}setBrushPosition(e){const t=this.brush,r=t.position;t.position=e;const n=G.subtract(e,r);n.squaredLength>0&&(t.velocity=new ee(n.x,n.y)),2===t.state&&t.positions.push(e)}setBrushRadius(e){this.brush.radius=e}setBrushState(e){const t=this.brush.state;this.brush.state=e,1!==e&&0!==e||2!==t||(this.brush.endStrokeNextFrame=!0)}setDisplayImage(e){this.displayImage=e}setFlowRate(e){this.update.flowRate=e}setIterationsPerFrame(e){this.iterationsPerFrame=e}setPaused(e){this.paused=e}setRates(e,t){const r=t,n=e,s=r*r,i=s*r,o=[51.6043*i-15.1554*s+1.2813*r+.02777,63.7108*i-17.505*s+1.3261*r+.03793];this.update.killRate=a(o[0],o[1],.01,.1,n),this.update.feedRate=r}setInkTexture(e){const t=new ee(e.width,e.height);this.textures.ink[0].update(t,e)}setOrientationMap(e){const t=new ee(e.width,e.height);this.textures.orientationMap.update(t,e)}setStyleMap(e){const t=new ee(e.width,e.height);this.textures.styleMap.update(t,e)}start(){const e=()=>{this.step(),requestAnimationFrame(e)};requestAnimationFrame(e)}step(){const e=this.programs.brushCutout,t=this.programs.canvasTexture,r=this.programs.diffuseInk,s=this.programs.display,i=this.programs.displayField,a=this.framebuffers,o=this.gl,l=this.textures,c=this.programs.simulate,d=O.translate(this.brush.position),u=this.brush.radius,h=O.dilate(new G(u,u,1)),m=O.multiply(d,h),p=O.multiply(this.camera.projection,m);o.bindFramebuffer(o.FRAMEBUFFER,a.state[0]),o.viewport(0,0,this.camera.width,this.camera.height),this.nextFrameChange.clear&&(o.clear(o.COLOR_BUFFER_BIT),this.nextFrameChange.clear=!1);const f=this.drawBrush(new n(0,1,0),this.programs.brushCutout);if(o.bindFramebuffer(o.FRAMEBUFFER,a.ink[0]),o.enable(o.BLEND),o.blendFunc(o.ONE,o.ONE_MINUS_SRC_ALPHA),this.drawBrush(this.brush.color,this.programs.brush),o.disable(o.BLEND),!this.paused&&!this.update.applyFlowMap){o.bindFramebuffer(o.FRAMEBUFFER,a.ink[1]),r.use(),l.ink[0].bind(0),o.drawArrays(o.TRIANGLE_STRIP,0,4);let e=l.ink[1];l.ink[1]=l.ink[0],l.ink[0]=e,e=a.ink[1],a.ink[1]=a.ink[0],a.ink[0]=e}if(!this.paused){c.use(),c.setUniform1f("canvas_feed_rate",this.update.feedRate),c.setUniform1f("flow_rate",this.update.flowRate),c.setUniform1f("canvas_kill_rate",this.update.killRate),c.setUniform1i("apply_orientation_map",this.update.applyOrientationMap),c.setUniform1i("apply_style_map",this.update.applyStyleMap);for(let e=0;e<=this.iterationsPerFrame;e++)l.state[e%2].bind(0),l.styleMap.bind(1),l.orientationMap.bind(2),o.bindFramebuffer(o.FRAMEBUFFER,a.state[e%2^1]),o.drawArrays(o.TRIANGLE_STRIP,0,4)}if(!this.paused&&this.update.applyFlowMap){this.flowSim.bindVelocityFramebuffer();let e=ee.multiply(.05,this.brush.velocity);e.length>1&&(e=ee.normalize(e)),this.drawBrush(new n(e.x,e.y,0),this.programs.brushCutout),this.flowSim.drawFlow(l.state[0],a.state[1]);let t=a.state[1];a.state[1]=a.state[0],a.state[0]=t,t=l.state[1],l.state[1]=l.state[0],l.state[0]=t,this.flowSim.advectInput(l.ink[0],a.ink[1]),t=l.ink[1],l.ink[1]=l.ink[0],l.ink[0]=t,t=a.ink[1],a.ink[1]=a.ink[0],a.ink[0]=t}switch(this.updateBrushAfterDrawing(f),o.bindFramebuffer(o.FRAMEBUFFER,null),o.viewport(0,0,this.camera.width,this.camera.height),this.displayImage){case"INK":t.use(),l.ink[0].bind(0),o.drawArrays(o.TRIANGLE_STRIP,0,4);break;case te:t.use(),l.orientationMap.bind(0),o.drawArrays(o.TRIANGLE_STRIP,0,4);break;case ne:t.use(),l.styleMap.bind(0),o.drawArrays(o.TRIANGLE_STRIP,0,4);break;case re:s.use(),s.setUniform4fv("background_color",this.update.backgroundColor.toRgba()),l.state[0].bind(0),l.ink[0].bind(1),o.drawArrays(o.TRIANGLE_STRIP,0,4);break;case se:this.flowSim.drawVelocityField(i)}2!==this.brush.state&&1!==this.brush.state||(o.enable(o.BLEND),o.blendFunc(o.SRC_ALPHA,o.ONE_MINUS_SRC_ALPHA),e.use(),l.brushShape.bind(0),e.setUniformMatrix4fv("model_view_projection",p.transpose.float32Array),e.setUniform4fv("brush_color",[0,1,0,.5]),o.drawArrays(o.TRIANGLE_STRIP,0,4),o.disable(o.BLEND))}updateBrushAfterDrawing(e){const t=this.brush;2===t.state&&t.positions.length>1&&(t.positions.splice(0,Math.max(t.positions.length-1,0)),t.strokeStepStart=e),t.endStrokeNextFrame&&(t.endStrokeNextFrame=!1,t.positions=[],t.strokeStepStart=0)}}class ae{constructor(e){const t=document.getElementById(e.id);this.checked=!1,this.disabled=!1,this.onChange=e.onChange,this.slideSwitch=t,this.onClick=this.onClick.bind(this),t.addEventListener("click",this.onClick)}setDisabled(e){this.disabled=e,e?this.slideSwitch.setAttribute("disabled","disabled"):this.slideSwitch.removeAttribute("disabled")}onClick(e){const t=e.currentTarget;this.checked=!this.checked,t.setAttribute("aria-checked",this.checked),this.onChange(this.checked)}}let oe,le,ce,de=[];function ue(e){return{identifier:e.pointerId,pageX:e.clientX,pageY:e.clientY}}function he(e,t){const r=le.getBoundingClientRect(),n=e-r.left-r.width/2,s=r.top-(t-r.height/2),i=le.width/r.width,a=le.height/r.height;return new G(i*n,a*s,0)}function me(e){return de.findIndex((t=>t.identifier===e))}function pe(){const e=new ee(le.width,le.height),t=ce.getBoundingClientRect(),r=t.height/t.width,n=t.width/t.height,s=e.y/e.x,i=e.x/e.y;let a,o;s<r?(a=95,o=95*s*n):(a=95*i*r,o=95),le.style.width=a.toPrecision(3)+"%",le.style.height=o.toPrecision(3)+"%"}const fe=new class{constructor(e){this.element=document.getElementById(e.id)}show(e){this.element.textContent=e,this.element.classList.remove("display-none")}}({id:"canvas-alert"}),_e=new ee(256,256);le=document.getElementById("canvas");try{oe=new ie(le,_e.x,_e.y)}catch(e){fe.show(e)}oe.start(),le.addEventListener("pointercancel",(function(e){const t=me(e.pointerId);t>=0&&(de.splice(t,1),de.length||oe.setBrushState(0))})),le.addEventListener("pointerdown",(function(e){oe.setBrushState(2),oe.setBrushPosition(he(e.clientX,e.clientY)),le.setPointerCapture(e.pointerId)})),le.addEventListener("pointerenter",(function(e){de.push(ue(e)),oe.setBrushState(1)})),le.addEventListener("pointermove",(function(e){const t=me(e.pointerId);t>=0&&de.splice(t,1,ue(e)),oe.setBrushState(e.pressure>0?2:1),oe.setBrushPosition(he(e.clientX,e.clientY))})),le.addEventListener("pointerout",(function(e){const t=me(e.pointerId);t>=0&&(de.splice(t,1),oe.setBrushState(0))})),le.addEventListener("pointerup",(function(e){oe.setBrushState(1),oe.setBrushPosition(he(e.clientX,e.clientY)),le.releasePointerCapture(e.pointerId)}));const ve=new l({id:"style-picker",boundsId:"style-picker-bounds",selectorId:"style-picker-selector",onInputChange:(e,t)=>{const r=i(.045,.07,e),n=i(.01,.1,t);oe.setRates(r,n)}});document.getElementById("flow-rate").addEventListener("input",(e=>{oe.setFlowRate(e.currentTarget.value)})),document.getElementById("iterations-per-frame").addEventListener("input",(e=>{oe.setIterationsPerFrame(e.currentTarget.value)})),new ae({id:"apply-flow-map",onChange:e=>{oe.setApplyFlowMap(e)}}),new ae({id:"apply-style-map",onChange:e=>{ve.setDisabled(e),oe.setApplyStyleMap(e)}}),new ae({id:"apply-orientation-map",onChange:e=>{oe.setApplyOrientationMap(e)}}),new d({buttonId:"background-color",initialColor:n.black(),onColorChange:e=>{oe.setBackgroundColor(e)}}),new d({buttonId:"brush-color",initialColor:n.black(),onColorChange:e=>{oe.setBrushColor(e)}}),document.getElementById("brush-radius").addEventListener("input",(e=>{oe.setBrushRadius(e.currentTarget.value)}));const xe={onSelect:e=>oe.setDisplayImage(e),tabs:[{id:"display-ink",displayImage:"INK"},{id:"display-orientation-map",displayImage:te},{id:"display-simulation",displayImage:re},{id:"display-style-map",displayImage:ne},{id:"display-velocity-field",displayImage:se}]};new class{constructor(e){this.onClick=this.onClick.bind(this),this.onSelect=e.onSelect,this.tabs=e.tabs.map((e=>({displayImage:e.displayImage,element:document.getElementById(e.id)})));for(const e of this.tabs)e.element.addEventListener("click",this.onClick)}onClick(e){const t=e.currentTarget;for(const e of this.tabs){const r=e.element;r===t?(r.setAttribute("aria-selected",!0),r.classList.add("tab-selected"),this.onSelect(e.displayImage)):(r.setAttribute("aria-selected",!1),r.classList.remove("tab-selected"))}}}(xe),document.getElementById("clear").addEventListener("click",(e=>oe.clear())),document.getElementById("download").addEventListener("click",(e=>{le.toBlob((e=>{h().saveAs(e,"Untitled.png")}),"image/png")})),new class{constructor(e){let t=e.paused;void 0===t&&(t=!1),this.onClick=this.onClick.bind(this),document.getElementById(e.id).addEventListener("click",this.onClick),this.onChange=e.onChange,this.paused=t}onClick(e){const t=e.currentTarget;this.paused=!this.paused,this.paused?(t.setAttribute("aria-label","play"),t.textContent="▶"):(t.setAttribute("aria-label","pause"),t.textContent="❙❙"),this.onChange(this.paused)}}({id:"pause",onChange:e=>oe.setPaused(e),paused:!1});const ye=document.getElementById("import-image-file"),ge=document.getElementById("import-image-map");document.getElementById("import-image").addEventListener("submit",(e=>{if(e.preventDefault(),0===ye.files.length)return!1;const t=ye.files[0],r=ge.value;(function(e){return"createImageBitmap"in window?window.createImageBitmap(e):function(e){return new Promise(((t,r)=>{let n;if(!(e instanceof Blob))throw new Error("The image source type is not supported.");n=URL.createObjectURL(e);const s=document.createElement("img");s.addEventListener("load",(e=>{t(this)})),s.src=n}))}(e)})(t).then((e=>{switch(r){case"ink":oe.setInkTexture(e);break;case"orientation-map":oe.setOrientationMap(e);break;case"style-map":oe.setStyleMap(e)}})).catch((e=>{console.error(e)}))}));const be=document.getElementById("canvas-size"),we=document.getElementById("canvas-width"),Ee=document.getElementById("canvas-height");ce=document.getElementById("canvas-wrapper"),be.addEventListener("submit",(e=>{e.preventDefault();const t=be.checkValidity();if(be.classList.add("was-validated"),!t)return!1;const r=parseInt(we.value),n=parseInt(Ee.value),s=new ee(r,n);oe.resize(s),pe()})),window.addEventListener("resize",(e=>{pe()})),pe()},213:function(e,t,r){var n,s;void 0===(s="function"==typeof(n=function(){"use strict";function t(e,t,r){var n=new XMLHttpRequest;n.open("GET",e),n.responseType="blob",n.onload=function(){o(n.response,t,r)},n.onerror=function(){console.error("could not download file")},n.send()}function n(e){var t=new XMLHttpRequest;t.open("HEAD",e,!1);try{t.send()}catch(e){}return 200<=t.status&&299>=t.status}function s(e){try{e.dispatchEvent(new MouseEvent("click"))}catch(r){var t=document.createEvent("MouseEvents");t.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),e.dispatchEvent(t)}}var i="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof r.g&&r.g.global===r.g?r.g:void 0,a=i.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),o=i.saveAs||("object"!=typeof window||window!==i?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(e,r,a){var o=i.URL||i.webkitURL,l=document.createElement("a");r=r||e.name||"download",l.download=r,l.rel="noopener","string"==typeof e?(l.href=e,l.origin===location.origin?s(l):n(l.href)?t(e,r,a):s(l,l.target="_blank")):(l.href=o.createObjectURL(e),setTimeout((function(){o.revokeObjectURL(l.href)}),4e4),setTimeout((function(){s(l)}),0))}:"msSaveOrOpenBlob"in navigator?function(e,r,i){if(r=r||e.name||"download","string"!=typeof e)navigator.msSaveOrOpenBlob(function(e,t){return void 0===t?t={autoBom:!1}:"object"!=typeof t&&(console.warn("Deprecated: Expected third argument to be a object"),t={autoBom:!t}),t.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob(["\ufeff",e],{type:e.type}):e}(e,i),r);else if(n(e))t(e,r,i);else{var a=document.createElement("a");a.href=e,a.target="_blank",setTimeout((function(){s(a)}))}}:function(e,r,n,s){if((s=s||open("","_blank"))&&(s.document.title=s.document.body.innerText="downloading..."),"string"==typeof e)return t(e,r,n);var o="application/octet-stream"===e.type,l=/constructor/i.test(i.HTMLElement)||i.safari,c=/CriOS\/[\d]+/.test(navigator.userAgent);if((c||o&&l||a)&&"undefined"!=typeof FileReader){var d=new FileReader;d.onloadend=function(){var e=d.result;e=c?e:e.replace(/^data:[^;]*;/,"data:attachment/file;"),s?s.location.href=e:location=e,s=null},d.readAsDataURL(e)}else{var u=i.URL||i.webkitURL,h=u.createObjectURL(e);s?s.location=h:location.href=h,s=null,setTimeout((function(){u.revokeObjectURL(h)}),4e4)}});i.saveAs=o.saveAs=o,e.exports=o})?n.apply(t,[]):n)||(e.exports=s)},825:e=>{e.exports="// Computes advection of a field through a velocity field using the implicit Euler method.\n\nprecision mediump float;\n\nuniform float delta_time;\nuniform sampler2D input_texture;\nuniform vec2 texture_size;\nuniform sampler2D velocity_field;\n\nvarying vec2 surface_texcoord;\n\n// WebGL 1.0 doesn't support use of the wrapping parameter GL_REPEAT for\n// non-power-of-two texture sizes. This manually implements that feature.\nvec4 sample_wrap(sampler2D input_sampler, vec2 texcoord)\n{\n    return texture2D(input_sampler, fract(texcoord));\n}\n\nvec4 sample_bilinear(sampler2D source, vec2 texel_size, vec2 sample_position)\n{\n    vec2 integral_part = floor(sample_position - 0.5) + 0.5;\n    vec2 fractional_part = sample_position - integral_part;\n    vec2 texcoord = texel_size * integral_part;\n\n    vec4 southwest = sample_wrap(source, texcoord);\n    vec4 northwest = sample_wrap(source, vec2(texcoord.x, texcoord.y + texel_size.y));\n    vec4 southeast = sample_wrap(source, vec2(texcoord.x + texel_size.x, texcoord.y));\n    vec4 northeast = sample_wrap(source, texcoord + texel_size);\n\n    vec4 north = mix(northwest, northeast, fractional_part.x);\n    vec4 south = mix(southwest, southeast, fractional_part.x);\n\n    return mix(south, north, fractional_part.y);\n}\n\nvoid main()\n{\n    vec2 texel_size = 1.0 / texture_size;\n    float inverse_aspect_ratio = texture_size.x / texture_size.y;\n\n    vec2 velocity = texture2D(velocity_field, surface_texcoord).xy;\n    vec2 texel_velocity = -0.5 * delta_time * velocity;\n    texel_velocity.y *= inverse_aspect_ratio;\n    vec2 sample_position = texture_size * (surface_texcoord + texel_velocity);\n\n    // Manually do the bilinear sample instead of using bilinear sampler\n    // parameters. This allows floating-point input textures to be sampled\n    // without requiring the OES_texture_float_linear extension.\n    gl_FragColor = sample_bilinear(input_texture, texel_size, sample_position);\n}"},498:e=>{e.exports="uniform mat4 model_view_projection;\n\nattribute vec2 position;\nattribute vec2 texcoord;\n\nvarying vec2 surface_texcoord;\n\nvoid main()\n{\n    gl_Position = model_view_projection * vec4(position, 0.0, 1.0);\n    surface_texcoord = texcoord;\n}"},679:e=>{e.exports="// Back and Forth Error Compensation And Correction\n// This program applies the compensation after the back and forth advection\n// computation.\n\nprecision mediump float;\n\nuniform sampler2D velocity_field;\nuniform sampler2D compensation_field;\n\nvarying vec2 surface_texcoord;\n\nvoid main()\n{\n    vec4 velocity = texture2D(velocity_field, surface_texcoord);\n    vec4 compensation = texture2D(compensation_field, surface_texcoord);\n    gl_FragColor = velocity + 0.5 * (velocity - compensation);\n}"},721:e=>{e.exports="precision mediump float;\n\nuniform sampler2D brush_shape;\nuniform vec4 brush_color;\n\nvarying vec2 surface_texcoord;\n\nvoid main()\n{\n    vec4 color = brush_color * texture2D(brush_shape, surface_texcoord);\n    if(color.a < 0.5)\n    {\n        discard;\n    }\n    gl_FragColor = vec4(color.rgb, 1.0);\n}"},404:e=>{e.exports="precision mediump float;\n\nuniform sampler2D brush_shape;\nuniform vec4 brush_color;\n\nvarying vec2 surface_texcoord;\n\nvoid main()\n{\n    vec4 shape_color = texture2D(brush_shape, surface_texcoord);\n    vec4 color = brush_color * shape_color;\n    \n    gl_FragColor = color;\n}"},762:e=>{e.exports="precision mediump float;\n\nuniform sampler2D image;\nuniform vec2 image_dimensions;\n\nvoid main()\n{\n    gl_FragColor = texture2D(image, gl_FragCoord.xy / image_dimensions);\n}"},849:e=>{e.exports="precision mediump float;\n\nuniform sampler2D ink;\nuniform vec2 texture_size;\n\nvarying vec2 surface_texcoord;\n\nconst float diffusion = 0.05;\nconst float flow_rate = 1.0;\nconst float TIMESTEP = 1.0;\n\nvec4 sample_wrap(sampler2D input_sampler, vec2 texcoord)\n{\n    return texture2D(input_sampler, fract(texcoord));\n}\n\nvec4 diffuse(vec2 center, vec2 texel_size)\n{\n    vec4 value = texture2D(ink, center);\n    vec4 northeast = sample_wrap(ink, center + texel_size * vec2(1.0, 1.0));\n    vec4 southeast = sample_wrap(ink, center + texel_size * vec2(1.0, -1.0));\n    vec4 southwest = sample_wrap(ink, center + texel_size * vec2(-1.0, -1.0));\n    vec4 northwest = sample_wrap(ink, center + texel_size * vec2(-1.0, 1.0));\n    vec4 north = sample_wrap(ink, center + texel_size * vec2(0.0, 1.0));\n    vec4 east = sample_wrap(ink, center + texel_size * vec2(1.0, 0.0));\n    vec4 south = sample_wrap(ink, center + texel_size * vec2(0.0, -1.0));\n    vec4 west = sample_wrap(ink, center + texel_size * vec2(-1.0, 0.0));\n\n    float db = diffusion * flow_rate;\n\n    float dxx = 0.5;\n    float dxy = 0.0;\n    float dyy = 0.5;\n\n    vec3 dv_mat1 = db * vec3(-dxy, 2.0 * dyy, dxy);\n    vec3 dv_mat2 = vec3(2.0 * dxx * db, diffusion * -4.0 * (dxx + dyy), 2.0 * dxx * db);\n    vec3 dv_mat3 = db * vec3(dxy, 2.0 * dyy, -dxy);\n\n    vec4 top = (dv_mat1.x * northwest) + (dv_mat1.y * north) + (dv_mat1.z * northeast);\n    vec4 middle = (dv_mat2.x * west) + (dv_mat2.y * value) + (dv_mat2.z * east);\n    vec4 bottom = (dv_mat3.x * southwest) + (dv_mat3.y * south) + (dv_mat3.z * southeast);\n    vec4 sum = top + middle + bottom;\n\n    return value + sum;\n}\n\nvoid main()\n{\n    vec2 texel_size = 1.0 / texture_size;\n\n    gl_FragColor = diffuse(surface_texcoord, texel_size);\n}"},349:e=>{e.exports="precision mediump float;\n\nuniform sampler2D field;\n\nvarying vec2 surface_texcoord;\n\nvoid main()\n{\n    vec2 sample = texture2D(field, surface_texcoord).xy;\n    vec2 value = (0.5 * sample) + 0.5;\n    gl_FragColor = vec4(value, 0.0, 1.0);\n}"},42:e=>{e.exports="precision mediump float;\n\nuniform sampler2D ink;\nuniform sampler2D state;\nuniform vec2 state_size;\nuniform vec4 background_color;\n\nconst float COLOR_MIN = 0.2;\nconst float COLOR_MAX = 0.4;\n\nvoid main()\n{\n    vec2 surface_texcoord = gl_FragCoord.xy / state_size;\n    vec2 chemicals = texture2D(state, surface_texcoord).xy;\n    float chemical_b = chemicals.y;\n    chemical_b = clamp(chemical_b, COLOR_MIN, COLOR_MAX);\n    float value = (chemical_b - COLOR_MIN) / (COLOR_MAX - COLOR_MIN);\n    vec3 ink_color = texture2D(ink, surface_texcoord).xyz;\n    gl_FragColor = vec4(mix(background_color.rgb, ink_color, value), 1.0);\n}"},661:e=>{e.exports="// Computes the divergence of a vector field.\n\nprecision mediump float;\n\nuniform float delta_time;\nuniform float density;\nuniform sampler2D velocity_field;\nuniform vec2 velocity_field_size;\n\nvarying vec2 surface_texcoord;\n\n// WebGL 1.0 doesn't support use of the wrapping parameter GL_REPEAT for\n// non-power-of-two texture sizes. This manually implements that feature.\nvec4 sample_wrap(sampler2D input_sampler, vec2 texcoord)\n{\n    return texture2D(input_sampler, fract(texcoord));\n}\n\nvoid main()\n{\n    vec2 pixel_size = 1.0 / velocity_field_size;\n    float east = sample_wrap(velocity_field, surface_texcoord + vec2(pixel_size.x, 0.0)).x;\n    float west = sample_wrap(velocity_field, surface_texcoord - vec2(pixel_size.x, 0.0)).x;\n    float north = sample_wrap(velocity_field, surface_texcoord + vec2(0.0, pixel_size.y)).y;\n    float south = sample_wrap(velocity_field, surface_texcoord - vec2(0.0, pixel_size.y)).y;\n    float divergence = (east - west) + (north - south);\n\n    // The divergence is multiplied by an extra term before being stored. This\n    // term is actually part of the pressure equation, but would have to be\n    // recalculated each iteration. So it's easier to do that step here.\n    float result = (-2.0 * pixel_size.x * density / delta_time) * divergence;\n\n    gl_FragColor = vec4(result, 0.0, 0.0, 1.0);\n}"},666:e=>{e.exports="attribute vec2 position;\n\nvoid main()\n{\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},177:e=>{e.exports="// Computes one iteration of pressure approximation using the Jacobi method.\n\nprecision mediump float;\n\nuniform sampler2D divergence_field;\nuniform sampler2D pressure_field;\nuniform vec2 field_size;\n\nvarying vec2 surface_texcoord;\n\n// WebGL 1.0 doesn't support use of the wrapping parameter GL_REPEAT for\n// non-power-of-two texture sizes. This manually implements that feature.\nvec4 sample_wrap(sampler2D input_sampler, vec2 texcoord)\n{\n    return texture2D(input_sampler, fract(texcoord));\n}\n\nvoid main()\n{\n    vec2 pixel_size = 1.0 / field_size;\n    float divergence = texture2D(divergence_field, surface_texcoord).x;\n    float west = sample_wrap(pressure_field, surface_texcoord - vec2(2.0 * pixel_size.x, 0.0)).x;\n    float east = sample_wrap(pressure_field, surface_texcoord + vec2(2.0 * pixel_size.x, 0.0)).x;\n    float south = sample_wrap(pressure_field, surface_texcoord - vec2(0.0, 2.0 * pixel_size.y)).x;\n    float north = sample_wrap(pressure_field, surface_texcoord + vec2(0.0, 2.0 * pixel_size.y)).x;\n    float pressure = 0.25 * (divergence + west + east + south + north);\n    gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}"},114:e=>{e.exports="precision mediump float;\n\nuniform sampler2D state;\nuniform sampler2D style_map;\nuniform sampler2D orientation_map;\nuniform vec2 state_size;\nuniform float canvas_feed_rate;\nuniform float canvas_kill_rate;\nuniform float flow_rate;\nuniform bool apply_orientation_map;\nuniform bool apply_style_map;\n\nconst vec2 diffusion = vec2(0.2, 0.1);\nconst float tau = 6.28318530718;\nconst float TIMESTEP = 1.0;\n\n// WebGL 1.0 doesn't support use of the wrapping parameter GL_REPEAT for\n// non-power-of-two texture sizes. This manually implements that feature.\nvec4 sample_wrap(sampler2D input_sampler, vec2 texcoord)\n{\n    return texture2D(input_sampler, fract(texcoord));\n}\n\nvoid main()\n{\n    vec2 center = gl_FragCoord.xy;\n\n    float feed_rate;\n    float kill_rate;\n    if(apply_style_map)\n    {\n        vec2 rates = texture2D(style_map, center / state_size).xy;\n        kill_rate = (0.09 * rates.x) + 0.01;\n        feed_rate = (0.025 * rates.y) + 0.045;\n    }\n    else\n    {\n        feed_rate = canvas_feed_rate;\n        kill_rate = canvas_kill_rate;\n    }\n\n    vec2 value = texture2D(state, center / state_size).xy;\n    vec2 northeast = sample_wrap(state, (center + vec2(1.0, 1.0)) / state_size).xy;\n    vec2 southeast = sample_wrap(state, (center + vec2(1.0, -1.0)) / state_size).xy;\n    vec2 southwest = sample_wrap(state, (center + vec2(-1.0, -1.0)) / state_size).xy;\n    vec2 northwest = sample_wrap(state, (center + vec2(-1.0, 1.0)) / state_size).xy;\n    vec2 north = sample_wrap(state, (center + vec2(0.0, 1.0)) / state_size).xy;\n    vec2 east = sample_wrap(state, (center + vec2(1.0, 0.0)) / state_size).xy;\n    vec2 south = sample_wrap(state, (center + vec2(0.0, -1.0)) / state_size).xy;\n    vec2 west = sample_wrap(state, (center + vec2(-1.0, 0.0)) / state_size).xy;\n\n    float dxx;\n    float dxy;\n    float dyy;\n    if(apply_orientation_map)\n    {\n        vec2 scale = vec2(0.7, 0.2);\n        vec2 direction = 2.0 * texture2D(orientation_map, center / state_size).xy - 1.0;\n        float direction_length = length(direction);\n        if(direction_length == 0.0)\n        {\n            direction = vec2(0.0, 0.0);\n        }\n        else\n        {\n            direction /= direction_length;\n        }\n        \n        float cos_angle = direction.x;\n        float sin_angle = direction.y;\n        \n        dxx = scale.x * (cos_angle * cos_angle) + scale.y * (sin_angle * sin_angle);\n        dxy = (scale.y - scale.x) * (cos_angle * sin_angle);\n        dyy = scale.y * (cos_angle * cos_angle) + scale.x * (sin_angle * sin_angle);\n    }\n    else\n    {\n        dxx = 0.5;\n        dxy = 0.0;\n        dyy = 0.5;\n    }\n\n    float da = diffusion.x * flow_rate;\n    float db = diffusion.y * flow_rate;\n    \n    vec3 du_mat1 = da * vec3(-dxy, 2.0 * dyy, dxy);\n    vec3 du_mat2 = vec3(2.0 * dxx * da, diffusion.x * -4.0 * (dxx + dyy), 2.0 * dxx * da);\n    vec3 du_mat3 = da * vec3(dxy, 2.0 * dyy, -dxy);\n\n    vec3 dv_mat1 = db * vec3(-dxy, 2.0 * dyy, dxy);\n    vec3 dv_mat2 = vec3(2.0 * dxx * db, diffusion.y * -4.0 * (dxx + dyy), 2.0 * dxx * db);\n    vec3 dv_mat3 = db * vec3(dxy, 2.0 * dyy, -dxy);\n\n    vec3 u_mat1 = vec3(northwest.x, north.x, northeast.x);\n    vec3 u_mat2 = vec3(west.x, value.x, east.x);\n    vec3 u_mat3 = vec3(southwest.x, south.x, southeast.x);\n\n    vec3 v_mat1 = vec3(northwest.y, north.y, northeast.y);\n    vec3 v_mat2 = vec3(west.y, value.y, east.y);\n    vec3 v_mat3 = vec3(southwest.y, south.y, southeast.y);\n\n    vec2 laplacian;\n    laplacian.x = dot(u_mat1, du_mat1) + dot(u_mat2, du_mat2) + dot(u_mat3, du_mat3);\n    laplacian.y = dot(v_mat1, dv_mat1) + dot(v_mat2, dv_mat2) + dot(v_mat3, dv_mat3);\n    float reaction = value.x * value.y * value.y;\n\n    vec2 delta;\n    delta.x = laplacian.x - reaction + (feed_rate * (1.0 - value.x));\n    delta.y = laplacian.y + reaction - (value.y * (kill_rate + feed_rate));\n\n    gl_FragColor = vec4((delta * TIMESTEP) + value, 0.0, 0.0);\n}"},973:e=>{e.exports="precision mediump float;\n\nuniform float delta_time;\nuniform float density;\nuniform vec2 field_size;\nuniform sampler2D pressure_field;\nuniform sampler2D velocity_field;\n\nvarying vec2 surface_texcoord;\n\n// WebGL 1.0 doesn't support use of the wrapping parameter GL_REPEAT for\n// non-power-of-two texture sizes. This manually implements that feature.\nvec4 sample_wrap(sampler2D input_sampler, vec2 texcoord)\n{\n    return texture2D(input_sampler, fract(texcoord));\n}\n\nvoid main()\n{\n    vec2 pixel_size = 1.0 / field_size;\n    \n    float west = sample_wrap(pressure_field, surface_texcoord - vec2(pixel_size.x, 0.0)).x;\n    float east = sample_wrap(pressure_field, surface_texcoord + vec2(pixel_size.x, 0.0)).x;\n    float south = sample_wrap(pressure_field, surface_texcoord - vec2(0.0, pixel_size.y)).x;\n    float north = sample_wrap(pressure_field, surface_texcoord + vec2(0.0, pixel_size.y)).x;\n    vec2 gradient = vec2(east - west, north - south);\n\n    vec2 velocity = texture2D(velocity_field, surface_texcoord).xy;\n    vec2 result = velocity - delta_time / (2.0 * density * pixel_size.x) * gradient;\n\n    gl_FragColor = vec4(result, 0.0, 1.0);\n}"}},e=>{e(e.s=694)}]);